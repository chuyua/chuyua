<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Android无障碍服务导致的全局卡顿分析 - Hexo</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


<link rel="stylesheet" href="https://at.alicdn.com/t/font_1736904_akkflqzx7j.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 80vh;">
    <a id="mdark" onclick="switchDarkMode()"></a>
<script>
  var isNight = new Date().getHours() >= 22 || new Date().getHours() <= 7;
  if(((matchMedia('(prefers-color-scheme: dark)').matches)||isNight||(localStorage.getItem('dark') === '1'))&&!(isNight&&localStorage.getItem('noDark') === '1')) {
    document.body.classList.add('dark');
  }
</script>
<nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/"><strong>Royce's world</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/gallery/">
              <i class="iconfont icon-xiangce1"></i>
              相册</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/messageboard/">
              <i class="iconfont icon-liuyan"></i>
              留言</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">
              <i class="iconfont icon-link-fill"></i>
              友链</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
        <li class="nav-item">
          <a id="dark" class="nav-link" onclick="switchDarkMode()"></a>
        </li>
      </ul>
    </div>
  </div>
</nav>
<script>
  document.getElementById('dark').innerHTML = document.querySelector("body").classList.contains("dark") ? '<i class="iconfont icon-moon"></i>' : '<i class="iconfont icon-sun"></i>';
  document.getElementById('mdark').innerHTML = document.querySelector("body").classList.contains("dark") ? '<i class="iconfont icon-moon"></i>' : '<i class="iconfont icon-sun"></i>';
</script>
 
    <div class="view intro-2" id="background" parallax=true
      style="background: url('https://rmt.dogedoge.com/fetch/royce/storage/bg/1.jpg?fmt=webp') no-repeat center center;
        background-size: cover;">
    <div class="view intro-2" id="background">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-02-15 23:22">
                    周六 2月 15 2020
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    2.3k
                  </span>
                

                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <span class="drop-cap">文</span>章转载自魅族系统性能优化工程师，对于某些要求开启无障碍的应用，不开源，不盈利又掌握着你系统的“最高权限”
<a id="more"></a>


<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>有用户反馈，手机在滑动的时候, 列表会一抖一抖的, 滑动桌面或者设置（只要是可以滑动的），都会出现，但是这个并不是必现，而是某些用户会出现，某些用户则不会出现。</p>
<p>吃瓜群众可以直接拉到下面看 罪魁祸首和自检 ，对分析问题比较感兴趣的可以看一下分析的过程。</p>
<h1 id="Systrace-分析"><a href="#Systrace-分析" class="headerlink" title="Systrace 分析"></a>Systrace 分析</h1><p>本地测试有一台复现, 拿过来之后分析发现,手指滑动桌面或者设置,都会必现卡顿, 从 Trace 上看就是下面这样<br><a href="https://www.androidperformance.com/images/media/performancecase/15482434530990.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482434530990.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>红色箭头处就是掉帧的地方. 从上面的 Buffer 个数可以看到, SF没有绘制的原因是 Launcher 没有提交 Buffer 上来.</p>
<p>对应的 Launcher Trace 如下 , 可以看到 Launcher 没有绘制的原因是没有 Input 事件传上来. 所以 Launcher 的画面没有更新, 所以才会出现掉帧.<br><a href="https://www.androidperformance.com/images/media/performancecase/15482435308066.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482435308066.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>没有事件上来这个本身就是有问题的 , 我们手指是连续从屏幕上划过的, 事件的上报应该是连续的才对, 我们怀疑是屏幕报点有问题, 不过 Check 硬件之前我们首先看一下 InputReader 和 InputDispatcher 线程是否正常工作</p>
<p><a href="https://www.androidperformance.com/images/media/performancecase/15482435458655.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482435458655.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>从图中可以看到 InputReader 线程是正常工作的 , 但是 InputDIspatcher 线程却有问题, 大家可以看一下正常情况下这两个线程的对应关系</p>
<p><a href="https://www.androidperformance.com/images/media/performancecase/15482435564755.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482435564755.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>再回到有问题的那个图 , 仔细看发现 InputDispatcher 线程的周期是和 Vsync 是相同的, 也就是说, InputDispatcher 的唤醒逻辑由 InputReader 唤醒变为由 Vsync 唤醒</p>
<p>再仔细看的话，点开 InputDIspatcher 的线程 cpu 状态可以看到， 唤醒执行任务的 InputDispatcher 线程并不是被 InputReader 线程唤醒的, 而是被 System_Server 的 UI Thread 唤醒的.</p>
<p>那么接下来， 就需要从代码的角度来看为什么 InputReader 没有唤醒 InputDIspatcher 。</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>InputReader 唤醒 InputDispatcher 线程的逻辑如下（以本例中的 Move 手势为例。），</p>
<p>frameworks/native/services/inputflinger/InputDispatcher.cpp</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::notifyMotion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;

    <span class="hljs-keyword">if</span> (!validateMotionEvent(args-&gt;action, args-&gt;actionButton,
                args-&gt;pointerCount, args-&gt;pointerProperties)) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">uint32_t</span> policyFlags = args-&gt;policyFlags;
    policyFlags |= POLICY_FLAG_TRUSTED;

    android::base::Timer t;
    mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;eventTime, <span class="hljs-comment">/*byref*/</span> policyFlags);
    <span class="hljs-keyword">if</span> (t.duration() &gt; SLOW_INTERCEPTION_THRESHOLD) &#123;
        ALOGW(<span class="hljs-string">"Excessive delay in interceptMotionBeforeQueueing; took %s ms"</span>,
                <span class="hljs-built_in">std</span>::to_string(t.duration().count()).c_str());
    &#125;

    <span class="hljs-keyword">bool</span> needWake; <span class="hljs-comment">//是否需要唤醒</span>
    &#123; <span class="hljs-comment">// acquire lock</span>
        mLock.lock();

        <span class="hljs-keyword">if</span> (shouldSendMotionToInputFilterLocked(args)) &#123;
            mLock.unlock();

            MotionEvent event;
            event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,
                    args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState,
                    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, args-&gt;xPrecision, args-&gt;yPrecision,
                    args-&gt;downTime, args-&gt;eventTime,
                    args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);

            policyFlags |= POLICY_FLAG_FILTERED;
            <span class="hljs-comment">// SystemServer 上层要对事件进行过滤</span>
            <span class="hljs-keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;
                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// event was consumed by the filter</span>
            &#125;

            mLock.lock();
        &#125;

        <span class="hljs-comment">// Just enqueue a new motion event.</span>
        MotionEntry* newEntry = <span class="hljs-keyword">new</span> MotionEntry(args-&gt;eventTime,
                args-&gt;deviceId, args-&gt;source, policyFlags,
                args-&gt;action, args-&gt;actionButton, args-&gt;flags,
                args-&gt;metaState, args-&gt;buttonState,
                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,
                args-&gt;displayId,
                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

        needWake = enqueueInboundEventLocked(newEntry); 
        mLock.unlock();
    &#125; <span class="hljs-comment">// release lock</span>

    <span class="hljs-keyword">if</span> (needWake) &#123;
        mLooper-&gt;wake();
    &#125;
&#125;</code></pre></div>

<p>需要注意这里 ，mPolicy-&gt;filterInputEvent 直接 return了，也就是说这里如果返回 false，那么就直接 return 了， 不继续执行下面的步骤。</p>
<p>继续看 mPolicy-&gt;filterInputEvent</p>
<p>frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">NativeInputManager::filterInputEvent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> InputEvent* inputEvent, <span class="hljs-keyword">uint32_t</span> policyFlags)</span> </span>&#123;
    ATRACE_CALL();
    jobject inputEventObj;

    JNIEnv* env = jniEnv();
    <span class="hljs-keyword">switch</span> (inputEvent-&gt;getType()) &#123;
    <span class="hljs-keyword">case</span> AINPUT_EVENT_TYPE_KEY:
        inputEventObj = android_view_KeyEvent_fromNative(env,
                <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> KeyEvent*&gt;(inputEvent));
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> AINPUT_EVENT_TYPE_MOTION:
        inputEventObj = android_view_MotionEvent_obtainAsCopy(env,
                <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> MotionEvent*&gt;(inputEvent));
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// dispatch the event normally</span>
    &#125;

     
    
    <span class="hljs-comment">// The callee is responsible for recycling the event.</span>
    jboolean pass = env-&gt;CallBooleanMethod(mServiceObj, gServiceClassInfo.filterInputEvent,
            inputEventObj, policyFlags);
    <span class="hljs-keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="hljs-string">"filterInputEvent"</span>)) &#123;
        pass = <span class="hljs-literal">true</span>;
    &#125;
    env-&gt;DeleteLocalRef(inputEventObj);
    <span class="hljs-keyword">return</span> pass;
&#125;</code></pre></div>

<p>这里从 jni 调回到 java 层， 也就是 InputManagerService 的 filterInputEvent 方法。</p>
<p>com/android/server/input/InputManagerService.java</p>
<div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-comment">// Native callback.</span>
<span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">filterInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-keyword">int</span> policyFlags)</span> </span>&#123;
    <span class="hljs-keyword">synchronized</span> (mInputFilterLock) &#123;
        <span class="hljs-keyword">if</span> (mInputFilter != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">try</span> &#123;
                mInputFilter.filterInputEvent(event, policyFlags);
            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
                <span class="hljs-comment">/* ignore */</span>
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
    &#125;
    event.recycle();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>

<p>跟代码流程发现, 这个 mInputFilter 是 AccessibilityInputFilter 的一个实例, 在 辅助功能里面打开开关的时候,会调用 AccessibilityManagerService 的 updateInputFilter 方法来设置 InputFilter.</p>
<p>android/view/InputFilter.java</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-keyword">int</span> policyFlags)</span> </span>&#123;
    mH.obtainMessage(MSG_INPUT_EVENT, policyFlags, <span class="hljs-number">0</span>, event).sendToTarget();
&#125;

<span class="hljs-keyword">case</span> MSG_INPUT_EVENT: &#123;
    <span class="hljs-keyword">final</span> InputEvent event = (InputEvent)msg.obj;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (mInboundInputEventConsistencyVerifier != <span class="hljs-keyword">null</span>) &#123;
            mInboundInputEventConsistencyVerifier.onInputEvent(event, <span class="hljs-number">0</span>);
        &#125;
        onInputEvent(event, msg.arg1);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        event.recycle();
    &#125;
    <span class="hljs-keyword">break</span>;
&#125;</code></pre></div>

<p>继续看 onInputEvent(event, msg.arg1);<br>com/android/server/accessibility/AccessibilityInputFilter.java</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-keyword">int</span> policyFlags)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mEventHandler == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">"mEventHandler == null for event "</span> + event);
        <span class="hljs-keyword">super</span>.onInputEvent(event, policyFlags);
        <span class="hljs-keyword">return</span>;
    &#125;

    EventStreamState state = getEventStreamState(event);
    <span class="hljs-keyword">if</span> (state == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">super</span>.onInputEvent(event, policyFlags);
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">int</span> eventSource = event.getSource();
    <span class="hljs-keyword">if</span> ((policyFlags &amp; WindowManagerPolicy.FLAG_PASS_TO_USER) == <span class="hljs-number">0</span>) &#123;
        state.reset();
        mEventHandler.clearEvents(eventSource);
        <span class="hljs-keyword">super</span>.onInputEvent(event, policyFlags);
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">if</span> (state.updateDeviceId(event.getDeviceId())) &#123;
        mEventHandler.clearEvents(eventSource);
    &#125;

    <span class="hljs-keyword">if</span> (!state.deviceIdValid()) &#123;
        <span class="hljs-keyword">super</span>.onInputEvent(event, policyFlags);
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> MotionEvent) &#123;
        <span class="hljs-keyword">if</span> ((mEnabledFeatures &amp; FEATURES_AFFECTING_MOTION_EVENTS) != <span class="hljs-number">0</span>) &#123;
            MotionEvent motionEvent = (MotionEvent) event;
            processMotionEvent(state, motionEvent, policyFlags);
            <span class="hljs-keyword">return</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">super</span>.onInputEvent(event, policyFlags);
        &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> KeyEvent) &#123;
        KeyEvent keyEvent = (KeyEvent) event;
        processKeyEvent(state, keyEvent, policyFlags);
    &#125;
&#125;</code></pre></div>

<p>继续看 processMotionEvent</p>
<div class="hljs"><pre><code class="hljs pf">private void processMotionEvent(EventStreamState <span class="hljs-keyword">state</span>, MotionEvent event, int policyFlags) &#123;
    if (!<span class="hljs-keyword">state</span>.shouldProcessScroll() &amp;&amp; event.getActionMasked() == MotionEvent.ACTION_SCROLL) &#123;
        super.<span class="hljs-keyword">on</span>InputEvent(event, policyFlags);
        return;
    &#125;

    if (!<span class="hljs-keyword">state</span>.shouldProcessMotionEvent(event)) &#123;
        return;
    &#125;

    batchMotionEvent(event, policyFlags);
&#125;</code></pre></div>

<p>继续看 batchMotionEvent</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">batchMotionEvent</span><span class="hljs-params">(MotionEvent event, <span class="hljs-keyword">int</span> policyFlags)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (DEBUG) &#123;
        Slog.i(TAG, <span class="hljs-string">"Batching event: "</span> + event + <span class="hljs-string">", policyFlags: "</span> + policyFlags);
    &#125;
    <span class="hljs-keyword">if</span> (mEventQueue == <span class="hljs-keyword">null</span>) &#123;
        mEventQueue = MotionEventHolder.obtain(event, policyFlags);
        scheduleProcessBatchedEvents();
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span> (mEventQueue.event.addBatch(event)) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    MotionEventHolder holder = MotionEventHolder.obtain(event, policyFlags);
    holder.next = mEventQueue;
    mEventQueue.previous = holder;
    mEventQueue = holder;
&#125;</code></pre></div>

<p>继续看 scheduleProcessBatchedEvents</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleProcessBatchedEvents</span><span class="hljs-params">()</span> </span>&#123;
    mChoreographer.postCallback(Choreographer.CALLBACK_INPUT,
            mProcessBatchedEventsRunnable, <span class="hljs-keyword">null</span>);
&#125;</code></pre></div>

<p>会在下一个 Vsync 周期的时候执行 mProcessBatchedEventsRunnable , 也就是 Choreographer.CALLBACK_INPUT ， 熟悉 Choregrapher 的同学应该知道这里在做什么。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable mProcessBatchedEventsRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> frameTimeNanos = mChoreographer.getFrameTimeNanos();
        &#125;
        processBatchedEvents(frameTimeNanos);
        <span class="hljs-keyword">if</span> (mEventQueue != <span class="hljs-keyword">null</span>) &#123;
            scheduleProcessBatchedEvents();
        &#125;
    &#125;
&#125;;</code></pre></div>

<p>那么代码在这里就比较清晰了， 是因为存在 AccessibilityInputFilter 导致 InputDIspatcher 线程没有被唤醒，而是把事件处理放到了下一个 Vsync 里面去处理。<br>结论</p>
<p>问题就在这个 Runnable 里面, 正常情况下, 如果没有打开 AccessibilityInputFilter , 那么上层不会对 Input 事件做任何的拦截, 一旦有 AccessibilityInputFilter , 那么就会走上面的逻辑, 这时候 InputDispatcher 不会跟着 InputReader 的节奏来走 , 而是跟着 Vsync 的节奏来走, 从 Trace 上也可看到这点;</p>
<p><a href="https://www.androidperformance.com/images/media/performancecase/15482437370372.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482437370372.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>那么这个 AccessibilityInputFilter 是从哪里来的呢？答案就是 Accessibility 服务，也就是常说的无障碍服务。</p>
<h1 id="罪魁祸首"><a href="#罪魁祸首" class="headerlink" title="罪魁祸首"></a>罪魁祸首</h1><p>经过上面的分析我们知道问题的原因是无障碍服务 ，无障碍服务的本质是为了服务哪些盲人之类的不方便操作的用户，但是某些 App 为了实现特定的功能，也加入了自己的 Accessibility 服务， 比如各大手机市场的“一键安装”功能，用户是方便了，但是用不好，也会有负面的作用，比如这一例，导致用户手机整机卡顿，不知道的用户，我估计都要退机了。</p>
<p>那么罪魁祸首是谁呢？目前发现有两个，一个讯飞输入法，一个是应用宝。打开 设置-系统-无障碍服务，可以看到里面的各种软件都有参与到，不过这个默认是关闭的，很多应用会引导用户去开启，许多用户不明所以，就稀里糊涂打开了。</p>
<p>无障碍服务页面如下：<br><a href="https://www.androidperformance.com/images/media/performancecase/15482437928005.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482437928005.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>关于无障碍服务有多NB，大家可以自己看看下面的弹框，这东西可以检测你的信用卡号和密码，至于短信内容、微信聊天内容那都是小 Case。</p>
<p><a href="https://www.androidperformance.com/images/media/performancecase/15482438028084.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482438028084.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<p>至于在这个例子里面引起整机卡顿的，就是下面这个 监听 ”执行手势“ 这个，一旦有应用监听这个的话， InputDIspatcher 线程就会走 Vsync 的周期，导致报点处理不及时，从而让滑动的对象以为这一帧没有事件进入，所以也没有内容的变更，就不会进行页面的更新，从而导致卡顿。<br><a href="https://www.androidperformance.com/images/media/performancecase/15482438143185.jpg" target="_blank" rel="noopener"><img src="https://www.androidperformance.com/images/media/performancecase/15482438143185.jpg" srcset="https://cdn.jsdelivr.net/gh/chuyua/imges@master/BlogSource/loading.webp" alt="img"></a></p>
<h1 id="自检"><a href="#自检" class="headerlink" title="自检"></a>自检</h1><p>如果你使用的是 Android 手机，强烈建议你关掉所有的无障碍服务（如果你不需要的话），像自动安装应用这种功能，不值得你为此付出这么大的风险。这个是 Android 原生的问题，我们在 Pixle 和 其他三方手机上都有发现这个问题。</p>
<ol>
<li>关闭路径：设置-系统-无障碍服务 ， 进去后把你已经打开的都关上。</li>
<li>强烈建议 <strong>应用宝、讯飞输入法</strong> ，不要监听手势事件。</li>
</ol>
<h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/55585722" target="_blank" rel="noopener">知乎 - Android 平台应用宝和讯飞输入法无障碍服务导致的全局卡顿分析</a></p>
<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>小厂系统研发工程师 , 更多信息可以点击 <a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</p>
<blockquote>
<p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p>
</blockquote>
<p>原文作者：<a href="https://androidperformance.com/" target="_blank" rel="noopener">Gracker</a></p>
<p>原文链接：<a href="https://androidperformance.com/2019/01/21/android-performance-case-jank-accessbility/" target="_blank" rel="noopener">https://androidperformance.com/2019/01/21/android-performance-case-jank-accessbility/</a></p>
<p>发表日期：<a href="https://androidperformance.com/2019/01/21/android-performance-case-jank-accessbility/" target="_blank" rel="noopener">一月 21日 2019, 12:22:22 凌晨</a></p>
<p>更新日期：<a href="https://androidperformance.com/2019/01/21/android-performance-case-jank-accessbility/" target="_blank" rel="noopener">November 4th 2019, 10:42:51 pm</a></p>
<p>版权声明：本文采用<a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/gh/royce2019/BlogSource/js/Valine.min.js"></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        lang: 'zh-cn',
        el: '#comments' ,
        app_id: 'BP0WteqAi1rLTH6C13A1Jfw8-gzGzoHsz',
        app_key: 'Xhohtk79OfxwRIBRi4ew2KhF',
        admin_email: '979093525@qq.com',
        placeholder: '说点什么...',
        emoticon_url: 'https://rmt.dogedoge.com/fetch/royce/storage/comments',
        emoticon_list: ["抓狂.png","无奈2.png","惊讶.png","托腮.png","快哭了.png","可怜.png","吃瓜.png","打哈欠.png","辣眼睛.png","脑阔疼.png","doge.png","动耳朵.gif","抖脚脚.gif","抖眼.gif","抖眼镜.gif","风吹秀发.gif","慌张.gif","夹住.gif","开车.gif","哭唧唧.gif","绿色的.gif","跳舞.gif","跳着走.gif","小花花.gif","眼睛转.gif","摇头.gif","眨眼.gif","吃东西.gif","弹肚皮.gif","动次打次.gif?fmt=webp ","比心心.gif","吹风.gif","打篮球.gif","都是小心心.gif","吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"となりのトトロ","artist":"伊藤サチコ","url":"https://cdn.jsdelivr.net/gh/Royce2019/img/01.mp3","cover":"https://cdn.jsdelivr.net/gh/Royce2019/img/img/109951163028865726.jpg"},{"name":"それがあなたの幸せとしても (カバー)","artist":"rairu","url":"https://cdn.jsdelivr.net/gh/Royce2019/img/02.mp3","cover":"https://cdn.jsdelivr.net/gh/Royce2019/img/img/109951163597938340.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    <div>
      powered by <a href="https://pages.github.com/" class="qr-trigger" target="_blank" rel="nofollow noopener">GitHub Pages</a>
    </div>
    

    
  <!-- 备案信息 -->
  <div>
    <a href="http://beian.miit.gov.cn/" target="_blank" class="beian-icp"
       rel="nofollow noopener">闽ICP备20005437号-1</a>
    
  </div>


    
    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>










<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Android无障碍服务导致的全局卡顿分析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>







  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  












</body>
</html>
